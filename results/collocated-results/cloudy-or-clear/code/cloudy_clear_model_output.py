#It takes the adress of 1 INSAT-3DR L1B file, the output is a cloudy/clear map generated by our own model. In addition to plotting the map, it also returns a dataframe containing latitude, longitude, model_prediction (cloudy or clear)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import h5py
import pickle
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib
import datetime
from cartopy.feature.nightshade import Nightshade
import matplotlib.colors as mcolors

cmap = mcolors.ListedColormap(['gray', 'white']) #gray is for clear sky, white is for cloudy sky

def model_output_func(insatfilepath, extent = -1):  
    #File reading
    insatfile = h5py.File(insatfilepath,'r')

    longitudearray = np.array(insatfile['Longitude'])/100
    latitudearray = np.array(insatfile['Latitude'])/100
    fillvalue = insatfile['Longitude'].attrs['_FillValue'][0]/100
    latitudearray[latitudearray == fillvalue] = np.nan
    longitudearray[longitudearray == fillvalue] = np.nan

    insatdate = str(insatfile.attrs['Acquisition_Date'])[2:-1]
    insattime = str(insatfile.attrs['Acquisition_Time_in_GMT'])[2:-1]
    acqstart = str(insatfile.attrs['Acquisition_Start_Time'])[2:-1].split('T')[1]
    acqend = str(insatfile.attrs['Acquisition_End_Time'])[2:-1].split('T')[1]

    #Converting counts to useful quantities like brightness temeprature, radiance and albedo.
    def count2bt(count,lut):
        bt = lut[count]
        return bt

    tir1count = np.array(insatfile['IMG_TIR1'])[0,:,:]
    fillvalue = insatfile['IMG_TIR1'].attrs['_FillValue'][0]
    tir1lut = np.array(insatfile['IMG_TIR1_TEMP'])
    tir1bt = count2bt(tir1count,tir1lut)
    tir1bt[tir1count == fillvalue] = np.nan

    tir2count = np.array(insatfile['IMG_TIR2'])[0,:,:]
    fillvalue = insatfile['IMG_TIR2'].attrs['_FillValue'][0]
    tir2lut = np.array(insatfile['IMG_TIR2_TEMP'])
    tir2bt = count2bt(tir2count,tir2lut)
    tir2bt[tir2count == fillvalue] = np.nan

    mircount = np.array(insatfile['IMG_MIR'])[0,:,:]
    fillvalue = insatfile['IMG_MIR'].attrs['_FillValue'][0]
    mirlut = np.array(insatfile['IMG_MIR_TEMP'])
    mirbt = count2bt(mircount,mirlut)
    mirbt[mircount == fillvalue] = np.nan

    swircount = np.array(insatfile['IMG_SWIR'])[0,:,:]
    fillvalue = insatfile['IMG_SWIR'].attrs['_FillValue'][0]
    swirlut = np.array(insatfile['IMG_SWIR_RADIANCE'])
    swirrad = count2bt(swircount,swirlut)
    swirrad[swircount == fillvalue] = np.nan

    viscount = np.array(insatfile['IMG_VIS'])[0,:,:]
    fillvalue = insatfile['IMG_VIS'].attrs['_FillValue'][0]
    vislut = np.array(insatfile['IMG_VIS_ALBEDO'])
    visalbedo = count2bt(viscount,vislut)
    visalbedo[viscount == fillvalue] = np.nan

    solarelevationarray = np.array(insatfile['Sun_Elevation'])[0,:,:]
    solarelevationarray = solarelevationarray/100
    fillvalue = insatfile['Sun_Elevation'].attrs['_FillValue'][0]/100
    solarelevationarray[solarelevationarray == fillvalue] = np.nan

    satelevationarray = np.array(insatfile['Sat_Elevation'])[0,:,:]
    satelevationarray = satelevationarray/100
    fillvalue = insatfile['Sat_Elevation'].attrs['_FillValue'][0]/100
    satelevationarray[satelevationarray == fillvalue] = np.nan
    print("File read successfully")

    #Downcaling the arrays with more resolution. The two arrays below have a res. of 1km, but others have res. of 4 km, so downscaling is required.
    swirraddown = swirrad[::4,::4]
    albedodown = visalbedo[::4,::4]
    
    #Dataframe for prediction
    dffullfile = pd.DataFrame({'albedo':albedodown.flatten(),'swirrad':swirraddown.flatten(),
                           'btmir':mirbt.flatten(),'bttir1':tir1bt.flatten(),'bttir2':tir2bt.flatten(),
                           'solarelevation':solarelevationarray.flatten(),'satelevation':satelevationarray.flatten(),
                           'longitude':longitudearray.flatten(),'latitude':latitudearray.flatten()})

    dffullfile.dropna(inplace=True)
    dfday = dffullfile[dffullfile['solarelevation'] > 0]
    #print(dfday.shape)
    dfnight = dffullfile[dffullfile['solarelevation'] <= 0]
    #print(dfnight.shape)

    dfdayfinal = dfday[['albedo','swirrad','btmir','bttir1','bttir2','solarelevation']]
    dfnightfinal = dfnight[['btmir','bttir1','bttir2','satelevation']]

    #Loading daytime model with its scaler
    scaleradress = r'/data/debasish/cloudetectionmodels/cloudyornomodel/rfmodels/y79acc8d2msl5mss150est/trainscaler.pkl' 
    modeladress = r'/data/debasish/cloudetectionmodels/cloudyornomodel/rfmodels/y79acc8d2msl5mss150est/randomforestclassifier.pkl'
    import joblib
    import pickle

    scaler = joblib.load(scaleradress)
    model = joblib.load(modeladress)

    dfdayscaled = scaler.transform(dfdayfinal)
    dayprediction = model.predict(dfdayscaled) #Scaling and predicting for daytime

    #Loading nighttime model with its scaler
    scaleradress = r'/data/debasish/cloudetectionmodels/cloudyornomodel/rfmodels/ironlywithsatelevation/trainscaler.pkl' 
    modeladress = r'/data/debasish/cloudetectionmodels/cloudyornomodel/rfmodels/ironlywithsatelevation/randomforestclassifier.pkl'

    scaler = joblib.load(scaleradress)
    model = joblib.load(modeladress)

    dfnightscaled = scaler.transform(dfnightfinal)
    nightprediction = model.predict(dfnightscaled) #Scaling and predicting for nightime

    print("Prediction done")

    dfday['prediction'] = list(dayprediction)
    dfnight['prediction'] = list(nightprediction)
    dfday['oldindex'] = dfday.index
    dfnight['oldindex'] = dfnight.index
    dfpredictioncombined = pd.concat([dfday,dfnight])
    dfpredictioncombined.sort_values(by=['oldindex'],inplace=True)

    fig = plt.figure(figsize=(10,8))
    cmap = mcolors.ListedColormap(['gray', 'white'])
    print("Plotting")

    ax = plt.axes(projection=ccrs.PlateCarree())
    
    plot = plt.scatter(dfpredictioncombined['longitude'][0:extent].values,
                    dfpredictioncombined['latitude'][0:extent].values,
                    c = dfpredictioncombined['prediction'][0:extent],
                    cmap=cmap,norm=matplotlib.colors.Normalize(vmin=0, vmax=1),
                    transform=ccrs.PlateCarree(),s=0.01)


    ax.set_global()

    gl = ax.gridlines(draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    #Set extent of the plot
    ax.set_extent([-10,160,-85,85], crs=ccrs.PlateCarree())
    #Assign blue to 1 and red to 0

    year  = int(insatdate[-4:])
    month_abbreviation = insatdate[2:5]
    month_number = datetime.datetime.strptime(month_abbreviation, '%b').month
    day   = int(insatdate[0:2])
    hour  = int(insattime[:2])
    minute = int(insattime[2:4])

    date = datetime.datetime(year,month_number,day,hour,minute,second=0)
    ax.add_feature(Nightshade(date, alpha=0.5))

    cbar = plt.colorbar(plot, orientation='horizontal', pad=0.035, fraction=0.019, aspect=50,ticks=[0, 1])
    cbar.set_label('Clear=0                                                    Cloudy=1', fontsize=16)
    cloudytoclearratio = len(dfpredictioncombined[dfpredictioncombined['prediction'] == 1])/len(dfpredictioncombined[dfpredictioncombined['prediction'] == 0])
    ax.coastlines(color = 'red')

    plt.title('Cloudy/Clear prediction from our {} model \n Date:{},Acquisition time: {}-{} (GMT)\n Cloudy pixels/Clear pixels ratio={:.3f}'.format(type(model).__name__,insatdate,acqstart,acqend,cloudytoclearratio))
    plt.show()

    return dfpredictioncombined

#Example given below
trialdataset = model_output_func(r'/data/debasish/insatdata/l1b/2019/2019jan/day01/3RIMG_01JAN2019_0315_L1B_STD_V01R00.h5',extent = -1);
